/* (c) Licensed under the MIT License. Created by rethmint. */

#ifndef __LIBREVMAPI__
#define __LIBREVMAPI__

/* Generated with cbindgen:0.26.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


enum ErrnoValue {
  Success = 0,
  Other = 1,
};
typedef int32_t ErrnoValue;

/**
 * This enum gives names to the status codes returned from Go callbacks to Rust.
 * The Go code will return one of these variants when returning.
 *
 * 0 means no error, all the other cases are some sort of error.
 *
 */
enum GoError {
  GoError_None = 0,
  /**
   * Go panicked for an unexpected reason.
   */
  GoError_Panic = 1,
  /**
   * Go received a bad argument from Rust
   */
  GoError_BadArgument = 2,
  /**
   * Error while trying to serialize data in Go code (typically json.Marshal)
   */
  GoError_CannotSerialize = 3,
  /**
   * An error happened during normal operation of a Go callback, which should be fed back to the contract
   */
  GoError_User = 4,
  /**
   * Unimplemented
   */
  GoError_Unimplemented = 5,
  /**
   * An error type that should never be created by us. It only serves as a fallback for the i32 to GoError conversion.
   */
  GoError_Other = -1,
};
typedef int32_t GoError;

typedef struct {

} evm_t;

typedef struct {

} compiler_t;

/**
 * An optional Vector type that requires explicit creation and destruction
 * and can be sent via FFI.
 * It can be created from `Option<Vec<u8>>` and be converted into `Option<Vec<u8>>`.
 *
 * This type is always created in Rust and always dropped in Rust.
 * If Go code want to create it, it must instruct Rust to do so via the
 * [`new_unmanaged_vector`] FFI export. If Go code wants to consume its data,
 * it must create a copy and instruct Rust to destroy it via the
 * [`destroy_unmanaged_vector`] FFI export.
 *
 * An UnmanagedVector is immutable.
 *
 * ## Ownership
 *
 * Ownership is the right and the obligation to destroy an `UnmanagedVector`
 * exactly once. Both Rust and Go can create an `UnmanagedVector`, which gives
 * then ownership. Sometimes it is necessary to transfer ownership.
 *
 * ### Transfer ownership from Rust to Go
 *
 * When an `UnmanagedVector` was created in Rust using [`UnmanagedVector::new`], [`UnmanagedVector::default`]
 * or [`new_unmanaged_vector`], it can be passted to Go as a return value.
 * Rust then has no chance to destroy the vector anymore, so ownership is transferred to Go.
 * In Go, the data has to be copied to a garbage collected `[]byte`. Then the vector must be destroyed
 * using [`destroy_unmanaged_vector`].
 *
 * ### Transfer ownership from Go to Rust
 *
 * When Rust code calls into Go (using the vtable methods), return data or error messages must be created
 * in Go. This is done by calling [`new_unmanaged_vector`] from Go, which copies data into a newly created
 * `UnmanagedVector`. Since Go created it, it owns it. The ownership is then passed to Rust via the
 * mutable return value pointers. On the Rust side, the vector is destroyed using [`UnmanagedVector::consume`].
 *
 */
typedef struct {
  /**
   * True if and only if this is None. If this is true, the other fields must be ignored.
   */
  bool is_none;
  uint8_t *ptr;
  size_t len;
  size_t cap;
} UnmanagedVector;

typedef struct {
  uint8_t _private[0];
} db_t;

/**
 * A view into a `Option<&[u8]>`, created and maintained by Rust.
 *
 * This can be copied into a []byte in Go.
 */
typedef struct {
  /**
   * True if and only if this is None. If this is true, the other fields must be ignored.
   */
  bool is_none;
  const uint8_t *ptr;
  size_t len;
} U8SliceView;

typedef struct {
  /**
   * Retrieves the storage root for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the storage root is being retrieved.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the result will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*get_storage_root)(db_t*, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Retrieves the code for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the code is being retrieved.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the result will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*get_code)(db_t*, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Retrieves the code hash for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the code hash is being retrieved.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the result will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*get_code_hash)(db_t*, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Retrieves the state for a given address and slot hash.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the state is being retrieved.
   * - `U8SliceView`: The slot hash for which the state is being retrieved.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the result will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*get_state)(db_t*, U8SliceView, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Retrieves the balance for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the balance is being retrieved.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the result will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*get_balance)(db_t*, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Retrieves the nonce for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the nonce is being retrieved.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the result will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*get_nonce)(db_t*, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Adds balance to a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address to which the balance is being added.
   * - `U8SliceView`: The amount of balance to add.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*add_balance)(db_t*, U8SliceView, U8SliceView, UnmanagedVector*);
  /**
   * Subtracts balance from a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address from which the balance is being subtracted.
   * - `U8SliceView`: The amount of balance to subtract.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*sub_balance)(db_t*, U8SliceView, U8SliceView, UnmanagedVector*);
  /**
   * Sets the balance for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the balance is being set.
   * - `U8SliceView`: The balance to set.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*set_balance)(db_t*, U8SliceView, U8SliceView, UnmanagedVector*);
  /**
   * Sets the nonce for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the nonce is being set.
   * - `u64`: The nonce to set.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*set_nonce)(db_t*, U8SliceView, uint64_t, UnmanagedVector*);
  /**
   * Sets the code for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the code is being set.
   * - `U8SliceView`: The code to set.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*set_code)(db_t*, U8SliceView, U8SliceView, UnmanagedVector*);
  /**
   * Sets the state for a given address and slot hash.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the state is being set.
   * - `U8SliceView`: The slot hash for which the state is being set.
   * - `U8SliceView`: The value to set.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*set_state)(db_t*, U8SliceView, U8SliceView, U8SliceView, UnmanagedVector*);
  /**
   * Sets the storage for a given address.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address for which the storage is being set.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where the storage input will be stored.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*set_storage)(db_t*, U8SliceView, UnmanagedVector*, UnmanagedVector*);
  /**
   * Marks the given account as selfdestructed.
   *
   * This clears the account balance. The account's state object is still available until the state is committed,
   * getStateObject will return a non-nil account after SelfDestruct.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `U8SliceView`: The address of the account to selfdestruct.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*self_destruct)(db_t*, U8SliceView, UnmanagedVector*);
  /**
   * Commits the state mutations into the configured data stores.
   *
   * # Parameters
   * - `db_t`: A mutable pointer to the database.
   * - `u64`: The block number associated with the state transition.
   * - `bool`: Flag indicating whether to delete empty objects.
   * - `UnmanagedVector`: A mutable pointer to an unmanaged vector where any error message will be stored.
   *
   * # Returns
   * - `i32`: Status code indicating success or failure.
   */
  int32_t (*commit)(db_t*, uint64_t, bool, UnmanagedVector*);
} Db_vtable;

typedef struct {
  db_t *state;
  Db_vtable vtable;
} Db;

/**
 * A view into an externally owned byte slice (Go `[]byte`).
 * Use this for the current call only. A view cannot be copied for safety reasons.
 * If you need a copy, use [`ByteSliceView::to_owned`].
 *
 * Go's nil value is fully supported, such that we can differentiate between nil and an empty slice.
 */
typedef struct {
  /**
   * True if and only if the byte slice is nil in Go. If this is true, the other fields must be ignored.
   */
  bool is_nil;
  const uint8_t *ptr;
  size_t len;
} ByteSliceView;

evm_t *create_vm(uint8_t default_spec_id);

evm_t *create_vm_with_compiler(uint8_t default_spec_id, compiler_t *compiler);

void destroy_unmanaged_vector(UnmanagedVector v);

UnmanagedVector execute_tx(evm_t *vm_ptr,
                           bool aot,
                           Db db,
                           ByteSliceView block,
                           ByteSliceView tx,
                           UnmanagedVector *errmsg);

compiler_t *init_compiler(uint64_t threshold);

UnmanagedVector new_unmanaged_vector(bool nil, const uint8_t *ptr, size_t length);

UnmanagedVector query_tx(evm_t *vm_ptr,
                         bool aot,
                         Db db,
                         ByteSliceView block,
                         ByteSliceView tx,
                         UnmanagedVector *errmsg);

void release_compiler(compiler_t *compiler);

void release_vm(evm_t *vm, bool aot);

#endif /* __LIBREVMAPI__ */
