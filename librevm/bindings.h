/* (c) 2024 initia labs. Licensed under BUSL-1.1 */

#ifndef __LIBMOVEVM__
#define __LIBMOVEVM__

/* Generated with cbindgen:0.26.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * * idea sep 17 * 1. Receive env from GoApi and initialize context * 2. Use the context to initialize vm * 3. Use the VM with the env to call 'call' and 'create' *
 */
typedef struct {

} vm_t;

/**
 * An optional Vector type that requires explicit creation and destruction
 * and can be sent via FFI.
 * It can be created from `Option<Vec<u8>>` and be converted into `Option<Vec<u8>>`.
 *
 * This type is always created in Rust and always dropped in Rust.
 * If Go code want to create it, it must instruct Rust to do so via the
 * [`new_unmanaged_vector`] FFI export. If Go code wants to consume its data,
 * it must create a copy and instruct Rust to destroy it via the
 * [`destroy_unmanaged_vector`] FFI export.
 *
 * An UnmanagedVector is immutable.
 *
 * ## Ownership
 *
 * Ownership is the right and the obligation to destroy an `UnmanagedVector`
 * exactly once. Both Rust and Go can create an `UnmanagedVector`, which gives
 * then ownership. Sometimes it is necessary to transfer ownership.
 *
 * ### Transfer ownership from Rust to Go
 *
 * When an `UnmanagedVector` was created in Rust using [`UnmanagedVector::new`], [`UnmanagedVector::default`]
 * or [`new_unmanaged_vector`], it can be passted to Go as a return value.
 * Rust then has no chance to destroy the vector anymore, so ownership is transferred to Go.
 * In Go, the data has to be copied to a garbage collected `[]byte`. Then the vector must be destroyed
 * using [`destroy_unmanaged_vector`].
 *
 * ### Transfer ownership from Go to Rust
 *
 * When Rust code calls into Go (using the vtable methods), return data or error messages must be created
 * in Go. This is done by calling [`new_unmanaged_vector`] from Go, which copies data into a newly created
 * `UnmanagedVector`. Since Go created it, it owns it. The ownership is then passed to Rust via the
 * mutable return value pointers. On the Rust side, the vector is destroyed using [`UnmanagedVector::consume`].
 *
 */
typedef struct {
  /**
   * True if and only if this is None. If this is true, the other fields must be ignored.
   */
  bool is_none;
  uint8_t *ptr;
  size_t len;
  size_t cap;
} UnmanagedVector;

/**
 * A view into an externally owned byte slice (Go `[]byte`).
 * Use this for the current call only. A view cannot be copied for safety reasons.
 * If you need a copy, use [`ByteSliceView::to_owned`].
 *
 * Go's nil value is fully supported, such that we can differentiate between nil and an empty slice.
 */
typedef struct {
  /**
   * True if and only if the byte slice is nil in Go. If this is true, the other fields must be ignored.
   */
  bool is_nil;
  const uint8_t *ptr;
  size_t len;
} ByteSliceView;

/**
 * A view into a `Option<&[u8]>`, created and maintained by Rust.
 *
 * This can be copied into a []byte in Go.
 */
typedef struct {
  /**
   * True if and only if this is None. If this is true, the other fields must be ignored.
   */
  bool is_none;
  const uint8_t *ptr;
  size_t len;
} U8SliceView;

typedef struct {
  uint8_t _private[0];
} api_t;

typedef struct {
  int32_t (*query)(const api_t*,
                   U8SliceView,
                   uint64_t,
                   UnmanagedVector*,
                   uint64_t*,
                   UnmanagedVector*);
  int32_t (*get_account_info)(const api_t*,
                              U8SliceView,
                              bool*,
                              uint64_t*,
                              uint64_t*,
                              uint8_t*,
                              bool*,
                              UnmanagedVector*);
  int32_t (*amount_to_share)(const api_t*,
                             U8SliceView,
                             U8SliceView,
                             uint64_t,
                             UnmanagedVector*,
                             UnmanagedVector*);
  int32_t (*share_to_amount)(const api_t*,
                             U8SliceView,
                             U8SliceView,
                             U8SliceView,
                             uint64_t*,
                             UnmanagedVector*);
  int32_t (*unbond_timestamp)(const api_t*, uint64_t*, UnmanagedVector*);
  int32_t (*get_price)(const api_t*,
                       U8SliceView,
                       UnmanagedVector*,
                       uint64_t*,
                       uint64_t*,
                       UnmanagedVector*);
} GoApi_vtable;

typedef struct {
  const api_t *state;
  GoApi_vtable vtable;
} GoApi;

vm_t *allocate_executor(void);

void destroy_unmanaged_vector(UnmanagedVector v);

UnmanagedVector initialize(ByteSliceView call_request_bytes);

UnmanagedVector new_unmanaged_vector(bool nil, const uint8_t *ptr, size_t length);

#endif /* __LIBMOVEVM__ */
