// automatically generated by the FlatBuffers compiler, do not modify


// @generated


extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod result {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EX_RESULT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EX_RESULT: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EX_RESULT: [ExResult; 5] = [
  ExResult::NONE,
  ExResult::Success,
  ExResult::Revert,
  ExResult::Halt,
  ExResult::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExResult(pub u8);
#[allow(non_upper_case_globals)]
impl ExResult {
  pub const NONE: Self = Self(0);
  pub const Success: Self = Self(1);
  pub const Revert: Self = Self(2);
  pub const Halt: Self = Self(3);
  pub const Error: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Success,
    Self::Revert,
    Self::Halt,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Success => Some("Success"),
      Self::Revert => Some("Revert"),
      Self::Halt => Some("Halt"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ExResult {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ExResult {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ExResult {
    type Output = ExResult;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ExResult {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ExResult {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ExResult {}
pub struct ExResultUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HALT_REASON_ENUM: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HALT_REASON_ENUM: u8 = 26;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HALT_REASON_ENUM: [HaltReasonEnum; 27] = [
  HaltReasonEnum::OutOfGasBasic,
  HaltReasonEnum::OutOfGasMemoryLimit,
  HaltReasonEnum::OutOfGasMemory,
  HaltReasonEnum::OutOfGasPrecompile,
  HaltReasonEnum::OutOfGasInvalidOperand,
  HaltReasonEnum::OpcodeNotFound,
  HaltReasonEnum::InvalidFEOpcode,
  HaltReasonEnum::InvalidJump,
  HaltReasonEnum::NotActivated,
  HaltReasonEnum::StackUnderflow,
  HaltReasonEnum::StackOverflow,
  HaltReasonEnum::OutOfOffset,
  HaltReasonEnum::CreateCollision,
  HaltReasonEnum::PrecompileError,
  HaltReasonEnum::NonceOverflow,
  HaltReasonEnum::CreateContractSizeLimit,
  HaltReasonEnum::CreateContractStartingWithEF,
  HaltReasonEnum::CreateInitCodeSizeLimit,
  HaltReasonEnum::OverflowPayment,
  HaltReasonEnum::StateChangeDuringStaticCall,
  HaltReasonEnum::CallNotAllowedInsideStatic,
  HaltReasonEnum::OutOfFunds,
  HaltReasonEnum::CallTooDeep,
  HaltReasonEnum::EOFFunctionStackOverflow,
  HaltReasonEnum::InvalidEXTCALLTarget,
  HaltReasonEnum::EofAuxDataOverflow,
  HaltReasonEnum::EofAuxDataTooSmall,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HaltReasonEnum(pub u8);
#[allow(non_upper_case_globals)]
impl HaltReasonEnum {
  pub const OutOfGasBasic: Self = Self(0);
  pub const OutOfGasMemoryLimit: Self = Self(1);
  pub const OutOfGasMemory: Self = Self(2);
  pub const OutOfGasPrecompile: Self = Self(3);
  pub const OutOfGasInvalidOperand: Self = Self(4);
  pub const OpcodeNotFound: Self = Self(5);
  pub const InvalidFEOpcode: Self = Self(6);
  pub const InvalidJump: Self = Self(7);
  pub const NotActivated: Self = Self(8);
  pub const StackUnderflow: Self = Self(9);
  pub const StackOverflow: Self = Self(10);
  pub const OutOfOffset: Self = Self(11);
  pub const CreateCollision: Self = Self(12);
  pub const PrecompileError: Self = Self(13);
  pub const NonceOverflow: Self = Self(14);
  pub const CreateContractSizeLimit: Self = Self(15);
  pub const CreateContractStartingWithEF: Self = Self(16);
  pub const CreateInitCodeSizeLimit: Self = Self(17);
  pub const OverflowPayment: Self = Self(18);
  pub const StateChangeDuringStaticCall: Self = Self(19);
  pub const CallNotAllowedInsideStatic: Self = Self(20);
  pub const OutOfFunds: Self = Self(21);
  pub const CallTooDeep: Self = Self(22);
  pub const EOFFunctionStackOverflow: Self = Self(23);
  pub const InvalidEXTCALLTarget: Self = Self(24);
  pub const EofAuxDataOverflow: Self = Self(25);
  pub const EofAuxDataTooSmall: Self = Self(26);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 26;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OutOfGasBasic,
    Self::OutOfGasMemoryLimit,
    Self::OutOfGasMemory,
    Self::OutOfGasPrecompile,
    Self::OutOfGasInvalidOperand,
    Self::OpcodeNotFound,
    Self::InvalidFEOpcode,
    Self::InvalidJump,
    Self::NotActivated,
    Self::StackUnderflow,
    Self::StackOverflow,
    Self::OutOfOffset,
    Self::CreateCollision,
    Self::PrecompileError,
    Self::NonceOverflow,
    Self::CreateContractSizeLimit,
    Self::CreateContractStartingWithEF,
    Self::CreateInitCodeSizeLimit,
    Self::OverflowPayment,
    Self::StateChangeDuringStaticCall,
    Self::CallNotAllowedInsideStatic,
    Self::OutOfFunds,
    Self::CallTooDeep,
    Self::EOFFunctionStackOverflow,
    Self::InvalidEXTCALLTarget,
    Self::EofAuxDataOverflow,
    Self::EofAuxDataTooSmall,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OutOfGasBasic => Some("OutOfGasBasic"),
      Self::OutOfGasMemoryLimit => Some("OutOfGasMemoryLimit"),
      Self::OutOfGasMemory => Some("OutOfGasMemory"),
      Self::OutOfGasPrecompile => Some("OutOfGasPrecompile"),
      Self::OutOfGasInvalidOperand => Some("OutOfGasInvalidOperand"),
      Self::OpcodeNotFound => Some("OpcodeNotFound"),
      Self::InvalidFEOpcode => Some("InvalidFEOpcode"),
      Self::InvalidJump => Some("InvalidJump"),
      Self::NotActivated => Some("NotActivated"),
      Self::StackUnderflow => Some("StackUnderflow"),
      Self::StackOverflow => Some("StackOverflow"),
      Self::OutOfOffset => Some("OutOfOffset"),
      Self::CreateCollision => Some("CreateCollision"),
      Self::PrecompileError => Some("PrecompileError"),
      Self::NonceOverflow => Some("NonceOverflow"),
      Self::CreateContractSizeLimit => Some("CreateContractSizeLimit"),
      Self::CreateContractStartingWithEF => Some("CreateContractStartingWithEF"),
      Self::CreateInitCodeSizeLimit => Some("CreateInitCodeSizeLimit"),
      Self::OverflowPayment => Some("OverflowPayment"),
      Self::StateChangeDuringStaticCall => Some("StateChangeDuringStaticCall"),
      Self::CallNotAllowedInsideStatic => Some("CallNotAllowedInsideStatic"),
      Self::OutOfFunds => Some("OutOfFunds"),
      Self::CallTooDeep => Some("CallTooDeep"),
      Self::EOFFunctionStackOverflow => Some("EOFFunctionStackOverflow"),
      Self::InvalidEXTCALLTarget => Some("InvalidEXTCALLTarget"),
      Self::EofAuxDataOverflow => Some("EofAuxDataOverflow"),
      Self::EofAuxDataTooSmall => Some("EofAuxDataTooSmall"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HaltReasonEnum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HaltReasonEnum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HaltReasonEnum {
    type Output = HaltReasonEnum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HaltReasonEnum {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HaltReasonEnum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HaltReasonEnum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SUCCESS_REASON_ENUM: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SUCCESS_REASON_ENUM: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SUCCESS_REASON_ENUM: [SuccessReasonEnum; 4] = [
  SuccessReasonEnum::Stop,
  SuccessReasonEnum::Return,
  SuccessReasonEnum::SelfDestruct,
  SuccessReasonEnum::EofReturnContract,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SuccessReasonEnum(pub u8);
#[allow(non_upper_case_globals)]
impl SuccessReasonEnum {
  pub const Stop: Self = Self(0);
  pub const Return: Self = Self(1);
  pub const SelfDestruct: Self = Self(2);
  pub const EofReturnContract: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Stop,
    Self::Return,
    Self::SelfDestruct,
    Self::EofReturnContract,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Stop => Some("Stop"),
      Self::Return => Some("Return"),
      Self::SelfDestruct => Some("SelfDestruct"),
      Self::EofReturnContract => Some("EofReturnContract"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SuccessReasonEnum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SuccessReasonEnum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SuccessReasonEnum {
    type Output = SuccessReasonEnum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SuccessReasonEnum {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SuccessReasonEnum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SuccessReasonEnum {}
pub enum TopicOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Topic<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Topic<'a> {
  type Inner = Topic<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Topic<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Topic { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TopicArgs<'args>
  ) -> flatbuffers::WIPOffset<Topic<'bldr>> {
    let mut builder = TopicBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Topic::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Topic<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct TopicArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TopicArgs<'a> {
  #[inline]
  fn default() -> Self {
    TopicArgs {
      value: None,
    }
  }
}

pub struct TopicBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TopicBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Topic::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TopicBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TopicBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Topic<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Topic<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Topic");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum LogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogData<'a> {
  type Inner = LogData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogData<'a> {
  pub const VT_TOPICS: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogDataArgs<'args>
  ) -> flatbuffers::WIPOffset<LogData<'bldr>> {
    let mut builder = LogDataBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.topics { builder.add_topics(x); }
    builder.finish()
  }


  #[inline]
  pub fn topics(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Topic<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Topic>>>>(LogData::VT_TOPICS, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(LogData::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for LogData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Topic>>>>("topics", Self::VT_TOPICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct LogDataArgs<'a> {
    pub topics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Topic<'a>>>>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for LogDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogDataArgs {
      topics: None,
      data: None,
    }
  }
}

pub struct LogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_topics(&mut self, topics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Topic<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogData::VT_TOPICS, topics);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogData::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogData");
      ds.field("topics", &self.topics());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum LogOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Log<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Log<'a> {
  type Inner = Log<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Log<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Log { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogArgs<'args>
  ) -> flatbuffers::WIPOffset<Log<'bldr>> {
    let mut builder = LogBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Log::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<LogData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LogData>>(Log::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for Log<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LogData>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct LogArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub data: Option<flatbuffers::WIPOffset<LogData<'a>>>,
}
impl<'a> Default for LogArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogArgs {
      address: None,
      data: None,
    }
  }
}

pub struct LogBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Log::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<LogData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LogData>>(Log::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Log<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Log<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Log");
      ds.field("address", &self.address());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum SuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Success<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Success<'a> {
  type Inner = Success<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Success<'a> {
  pub const VT_REASON: flatbuffers::VOffsetT = 4;
  pub const VT_GAS_USED: flatbuffers::VOffsetT = 6;
  pub const VT_GAS_REFUNDED: flatbuffers::VOffsetT = 8;
  pub const VT_LOGS: flatbuffers::VOffsetT = 10;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 12;
  pub const VT_DEPLOYED_ADDRESS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Success { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SuccessArgs<'args>
  ) -> flatbuffers::WIPOffset<Success<'bldr>> {
    let mut builder = SuccessBuilder::new(_fbb);
    builder.add_gas_refunded(args.gas_refunded);
    builder.add_gas_used(args.gas_used);
    if let Some(x) = args.deployed_address { builder.add_deployed_address(x); }
    if let Some(x) = args.output { builder.add_output(x); }
    if let Some(x) = args.logs { builder.add_logs(x); }
    builder.add_reason(args.reason);
    builder.finish()
  }


  #[inline]
  pub fn reason(&self) -> SuccessReasonEnum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SuccessReasonEnum>(Success::VT_REASON, Some(SuccessReasonEnum::Stop)).unwrap()}
  }
  #[inline]
  pub fn gas_used(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Success::VT_GAS_USED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn gas_refunded(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Success::VT_GAS_REFUNDED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn logs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Log<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Log>>>>(Success::VT_LOGS, None)}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Success::VT_OUTPUT, None)}
  }
  #[inline]
  pub fn deployed_address(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Success::VT_DEPLOYED_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for Success<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SuccessReasonEnum>("reason", Self::VT_REASON, false)?
     .visit_field::<u64>("gas_used", Self::VT_GAS_USED, false)?
     .visit_field::<u64>("gas_refunded", Self::VT_GAS_REFUNDED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Log>>>>("logs", Self::VT_LOGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("output", Self::VT_OUTPUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("deployed_address", Self::VT_DEPLOYED_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct SuccessArgs<'a> {
    pub reason: SuccessReasonEnum,
    pub gas_used: u64,
    pub gas_refunded: u64,
    pub logs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Log<'a>>>>>,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub deployed_address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SuccessArgs<'a> {
  #[inline]
  fn default() -> Self {
    SuccessArgs {
      reason: SuccessReasonEnum::Stop,
      gas_used: 0,
      gas_refunded: 0,
      logs: None,
      output: None,
      deployed_address: None,
    }
  }
}

pub struct SuccessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SuccessBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reason(&mut self, reason: SuccessReasonEnum) {
    self.fbb_.push_slot::<SuccessReasonEnum>(Success::VT_REASON, reason, SuccessReasonEnum::Stop);
  }
  #[inline]
  pub fn add_gas_used(&mut self, gas_used: u64) {
    self.fbb_.push_slot::<u64>(Success::VT_GAS_USED, gas_used, 0);
  }
  #[inline]
  pub fn add_gas_refunded(&mut self, gas_refunded: u64) {
    self.fbb_.push_slot::<u64>(Success::VT_GAS_REFUNDED, gas_refunded, 0);
  }
  #[inline]
  pub fn add_logs(&mut self, logs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Log<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Success::VT_LOGS, logs);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Success::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_deployed_address(&mut self, deployed_address: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Success::VT_DEPLOYED_ADDRESS, deployed_address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SuccessBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SuccessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Success<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Success<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Success");
      ds.field("reason", &self.reason());
      ds.field("gas_used", &self.gas_used());
      ds.field("gas_refunded", &self.gas_refunded());
      ds.field("logs", &self.logs());
      ds.field("output", &self.output());
      ds.field("deployed_address", &self.deployed_address());
      ds.finish()
  }
}
pub enum RevertOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Revert<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Revert<'a> {
  type Inner = Revert<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Revert<'a> {
  pub const VT_GAS_USED: flatbuffers::VOffsetT = 4;
  pub const VT_OUTPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Revert { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RevertArgs<'args>
  ) -> flatbuffers::WIPOffset<Revert<'bldr>> {
    let mut builder = RevertBuilder::new(_fbb);
    builder.add_gas_used(args.gas_used);
    if let Some(x) = args.output { builder.add_output(x); }
    builder.finish()
  }


  #[inline]
  pub fn gas_used(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Revert::VT_GAS_USED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn output(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Revert::VT_OUTPUT, None)}
  }
}

impl flatbuffers::Verifiable for Revert<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("gas_used", Self::VT_GAS_USED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("output", Self::VT_OUTPUT, false)?
     .finish();
    Ok(())
  }
}
pub struct RevertArgs<'a> {
    pub gas_used: u64,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RevertArgs<'a> {
  #[inline]
  fn default() -> Self {
    RevertArgs {
      gas_used: 0,
      output: None,
    }
  }
}

pub struct RevertBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RevertBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_gas_used(&mut self, gas_used: u64) {
    self.fbb_.push_slot::<u64>(Revert::VT_GAS_USED, gas_used, 0);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Revert::VT_OUTPUT, output);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RevertBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RevertBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Revert<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Revert<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Revert");
      ds.field("gas_used", &self.gas_used());
      ds.field("output", &self.output());
      ds.finish()
  }
}
pub enum HaltOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Halt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Halt<'a> {
  type Inner = Halt<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Halt<'a> {
  pub const VT_REASON: flatbuffers::VOffsetT = 4;
  pub const VT_GAS_USED: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Halt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HaltArgs
  ) -> flatbuffers::WIPOffset<Halt<'bldr>> {
    let mut builder = HaltBuilder::new(_fbb);
    builder.add_gas_used(args.gas_used);
    builder.add_reason(args.reason);
    builder.finish()
  }


  #[inline]
  pub fn reason(&self) -> HaltReasonEnum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<HaltReasonEnum>(Halt::VT_REASON, Some(HaltReasonEnum::OutOfGasBasic)).unwrap()}
  }
  #[inline]
  pub fn gas_used(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Halt::VT_GAS_USED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Halt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<HaltReasonEnum>("reason", Self::VT_REASON, false)?
     .visit_field::<u64>("gas_used", Self::VT_GAS_USED, false)?
     .finish();
    Ok(())
  }
}
pub struct HaltArgs {
    pub reason: HaltReasonEnum,
    pub gas_used: u64,
}
impl<'a> Default for HaltArgs {
  #[inline]
  fn default() -> Self {
    HaltArgs {
      reason: HaltReasonEnum::OutOfGasBasic,
      gas_used: 0,
    }
  }
}

pub struct HaltBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HaltBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reason(&mut self, reason: HaltReasonEnum) {
    self.fbb_.push_slot::<HaltReasonEnum>(Halt::VT_REASON, reason, HaltReasonEnum::OutOfGasBasic);
  }
  #[inline]
  pub fn add_gas_used(&mut self, gas_used: u64) {
    self.fbb_.push_slot::<u64>(Halt::VT_GAS_USED, gas_used, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HaltBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HaltBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Halt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Halt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Halt");
      ds.field("reason", &self.reason());
      ds.field("gas_used", &self.gas_used());
      ds.finish()
  }
}
pub enum ErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Error<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Error<'a> {
  type Inner = Error<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Error<'a> {
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Error { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorArgs<'args>
  ) -> flatbuffers::WIPOffset<Error<'bldr>> {
    let mut builder = ErrorBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.finish()
  }


  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for Error<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorArgs {
      message: None,
    }
  }
}

pub struct ErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Error<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Error");
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum EvmResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EvmResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EvmResult<'a> {
  type Inner = EvmResult<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EvmResult<'a> {
  pub const VT_RESULT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_RESULT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EvmResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EvmResultArgs
  ) -> flatbuffers::WIPOffset<EvmResult<'bldr>> {
    let mut builder = EvmResultBuilder::new(_fbb);
    if let Some(x) = args.result { builder.add_result(x); }
    builder.add_result_type(args.result_type);
    builder.finish()
  }


  #[inline]
  pub fn result_type(&self) -> ExResult {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ExResult>(EvmResult::VT_RESULT_TYPE, Some(ExResult::NONE)).unwrap()}
  }
  #[inline]
  pub fn result(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EvmResult::VT_RESULT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn result_as_success(&self) -> Option<Success<'a>> {
    if self.result_type() == ExResult::Success {
      self.result().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Success::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn result_as_revert(&self) -> Option<Revert<'a>> {
    if self.result_type() == ExResult::Revert {
      self.result().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Revert::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn result_as_halt(&self) -> Option<Halt<'a>> {
    if self.result_type() == ExResult::Halt {
      self.result().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Halt::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn result_as_error(&self) -> Option<Error<'a>> {
    if self.result_type() == ExResult::Error {
      self.result().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Error::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for EvmResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ExResult, _>("result_type", Self::VT_RESULT_TYPE, "result", Self::VT_RESULT, false, |key, v, pos| {
        match key {
          ExResult::Success => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Success>>("ExResult::Success", pos),
          ExResult::Revert => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Revert>>("ExResult::Revert", pos),
          ExResult::Halt => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Halt>>("ExResult::Halt", pos),
          ExResult::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("ExResult::Error", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct EvmResultArgs {
    pub result_type: ExResult,
    pub result: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EvmResultArgs {
  #[inline]
  fn default() -> Self {
    EvmResultArgs {
      result_type: ExResult::NONE,
      result: None,
    }
  }
}

pub struct EvmResultBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EvmResultBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_result_type(&mut self, result_type: ExResult) {
    self.fbb_.push_slot::<ExResult>(EvmResult::VT_RESULT_TYPE, result_type, ExResult::NONE);
  }
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvmResult::VT_RESULT, result);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EvmResultBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EvmResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EvmResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EvmResult<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EvmResult");
      ds.field("result_type", &self.result_type());
      match self.result_type() {
        ExResult::Success => {
          if let Some(x) = self.result_as_success() {
            ds.field("result", &x)
          } else {
            ds.field("result", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ExResult::Revert => {
          if let Some(x) = self.result_as_revert() {
            ds.field("result", &x)
          } else {
            ds.field("result", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ExResult::Halt => {
          if let Some(x) = self.result_as_halt() {
            ds.field("result", &x)
          } else {
            ds.field("result", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ExResult::Error => {
          if let Some(x) = self.result_as_error() {
            ds.field("result", &x)
          } else {
            ds.field("result", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("result", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EvmResult`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evm_result_unchecked`.
pub fn root_as_evm_result(buf: &[u8]) -> Result<EvmResult, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EvmResult>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EvmResult` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_evm_result_unchecked`.
pub fn size_prefixed_root_as_evm_result(buf: &[u8]) -> Result<EvmResult, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EvmResult>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EvmResult` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evm_result_unchecked`.
pub fn root_as_evm_result_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvmResult<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EvmResult<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EvmResult` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evm_result_unchecked`.
pub fn size_prefixed_root_as_evm_result_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvmResult<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EvmResult<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EvmResult and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EvmResult`.
pub unsafe fn root_as_evm_result_unchecked(buf: &[u8]) -> EvmResult {
  flatbuffers::root_unchecked::<EvmResult>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EvmResult and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EvmResult`.
pub unsafe fn size_prefixed_root_as_evm_result_unchecked(buf: &[u8]) -> EvmResult {
  flatbuffers::size_prefixed_root_unchecked::<EvmResult>(buf)
}
#[inline]
pub fn finish_evm_result_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EvmResult<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_evm_result_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EvmResult<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod result

